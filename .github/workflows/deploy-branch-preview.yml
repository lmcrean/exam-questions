name: Deploy Branch Preview

# IMPORTANT: Branch-Specific CI Workflow Logic
#
# This workflow uses `pull_request_target` which normally runs workflows from the BASE branch (main)
# for security reasons. However, for deployment branches, we want to use the PR branch's version
# of CI workflows so that:
#
# 1. Tests added/removed in the branch are reflected in CI
# 2. Changes to CI configuration in the branch take effect immediately
# 3. Deleted problematic tests don't continue running from main's version
#
# Solution: Use full repository path with branch ref for reusable workflows:
#   ✅ uses: owner/repo/.github/workflows/reusable-test.yml@${{ github.head_ref }}
#   ❌ uses: ./.github/workflows/reusable-test.yml (uses main's version)
#
# This ensures deployment branches run THEIR CI workflows, not main's workflows.

on:
  pull_request_target:
    types: [opened, synchronize, reopened, labeled]
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write
  deployments: write
  checks: write
  id-token: write

jobs:
  check-authorization:
    runs-on: ubuntu-latest
    # Skip this job if triggered by a label event that's not the deploy-preview label
    if: github.event_name != 'labeled' || github.event.label.name == 'deploy-preview'
    outputs:
      authorized: ${{ steps.check.outputs.authorized }}
      pr_number: ${{ steps.check.outputs.pr_number }}
    steps:
      - name: Check if deployment is authorized
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            // Handle both pull_request_target and workflow_dispatch events
            let prNumber, prAuthor;

            if (context.eventName === 'workflow_dispatch') {
              // For manual triggers, get PR info from the branch
              const { data: prs } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head: `${context.repo.owner}:${context.ref.replace('refs/heads/', '')}`,
                state: 'open'
              });

              if (prs.length === 0) {
                core.setOutput('authorized', 'false');
                core.notice('No open PR found for this branch');
                return;
              }

              prNumber = prs[0].number;
              prAuthor = prs[0].user.login;
            } else {
              // For pull_request_target events
              prNumber = context.payload.pull_request.number;
              prAuthor = context.payload.pull_request.user.login;
            }

            // Set PR number as output for use by other jobs
            core.setOutput('pr_number', prNumber.toString());

            // Check if author is a collaborator
            let isCollaborator = false;
            try {
              const { data: permission } = await github.rest.repos.getCollaboratorPermissionLevel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                username: prAuthor
              });
              // Collaborators have 'admin', 'write', or 'read' permission
              isCollaborator = ['admin', 'write', 'read'].includes(permission.permission);
              console.log(`User ${prAuthor} permission level: ${permission.permission}`);
            } catch (error) {
              console.log(`User ${prAuthor} is not a collaborator`);
            }

            // If user is a collaborator, authorize immediately
            if (isCollaborator) {
              console.log(`Authorized: ${prAuthor} is a repository collaborator`);
              core.setOutput('authorized', 'true');
              return;
            }

            // For external contributors, check for the deploy-preview label
            console.log(`External contributor detected: ${prAuthor}`);
            const { data: labels } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });

            const hasDeployLabel = labels.some(label => label.name === 'deploy-preview');

            if (hasDeployLabel) {
              console.log(`Authorized: PR #${prNumber} has 'deploy-preview' label`);
              core.setOutput('authorized', 'true');
            } else {
              console.log(`Not authorized: External contributor without 'deploy-preview' label`);
              console.log(`A maintainer must add the 'deploy-preview' label to trigger deployment`);
              core.setOutput('authorized', 'false');

              // Post a comment explaining the situation
              try {
                const { data: comments } = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber
                });

                const botComment = comments.find(comment =>
                  comment.user.type === 'Bot' &&
                  comment.body.includes('DEPLOY_AUTHORIZATION_NEEDED')
                );

                if (!botComment) {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    body: 'Deployment Authorization Required\n\nThank you for your contribution! As an external contributor, your PR requires manual approval before deployment previews are created.\n\nFor maintainers: Add the deploy-preview label to this PR to trigger the deployment workflow.\n\nDEPLOY_AUTHORIZATION_NEEDED'
                  });
                }
              } catch (error) {
                console.log('Failed to post comment:', error.message);
              }

              // Don't fail the job - just set authorized to false and let deploy job skip
              core.notice('Deployment paused - waiting for deploy-preview label');
            }

  deploy:
    needs: check-authorization
    if: needs.check-authorization.outputs.authorized == 'true'
    # Use branch-specific workflow for deployment branches
    # This ensures deployment branches use THEIR version of CI workflows, not main's
    uses: lmcrean/ed-tech-app/.github/workflows/reusable-deploy.yml@${{ github.head_ref || github.ref_name }}
    secrets: inherit
    with:
      deployment_type: 'branch'
      branch_name: ${{ github.head_ref || github.ref_name }}
      pr_number: ${{ needs.check-authorization.outputs.pr_number }}
      # Use GitHub Environment for one-time approval per PR
      # After initial approval, all subsequent commits auto-deploy
      environment: 'preview-deployments'

  test:
    needs: [check-authorization, deploy]
    # Use branch-specific workflow for testing
    # This ensures deployment branches use THEIR version of test workflows, not main's
    # Critical for cases where tests are added/removed/modified in the branch
    uses: lmcrean/ed-tech-app/.github/workflows/reusable-test.yml@${{ github.head_ref || github.ref_name }}
    secrets: inherit
    with:
      api_url: ${{ needs.deploy.outputs.api_url }}
      web_url: ${{ needs.deploy.outputs.web_url }}
      deployment_type: 'branch'
      branch_name: ${{ github.head_ref || github.ref_name }}
      pr_number: ${{ needs.check-authorization.outputs.pr_number }}
